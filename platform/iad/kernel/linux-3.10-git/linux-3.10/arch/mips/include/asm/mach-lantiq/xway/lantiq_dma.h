/*
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License version 2 as published
 *  by the Free Software Foundation.
 *
 *  Copyright (C) 2009~1012 Reddy <Reddy.Mallikarjun@lantiq.com>
 *  Copyright (C) 2013 Lei Chuanhua <chuanhua.lei@lantiq.com>
 */
#ifndef LANTIQ_DMA_H
#define LANTIQ_DMA_H
/*!
  \defgroup LTQ_DMA_CORE UEIP Project - Central DMA core driver
  \brief UEIP Project - Central DMA core Module, supports LTQ CPE
  \ platforms(Danube/ASE/ARx/VRx/GRX).
 */

/*!
  \defgroup LTQ_DMA_DRV_API External APIs
  \ingroup LTQ_DMA_CORE
  \brief External APIs definitions for other modules.
 */

/*!
  \defgroup LTQ_DMA_DRV_STRUCTURE Driver Structures
  \ingroup LTQ_DMA_CORE
  \brief Definitions/Structures of LTQ dma core module.
 */

/*!
  \file lantiq_dma.h
  \ingroup LTQ_DMA_CORE
  \brief Header file for LTQ Central DMA core driver
 */

#define MAX_DMA_DEVICE_NUM              7

#define MAX_DMA_CHANNEL_NUM             28

#define DMA_DEV_NAME_LEN                8

/** Config the Num of descriptors from Kernel configurations
* or else if will take default number of  descriptors per channel
*/

#define MAX_DMA_DESC_NUM               255


/*!
  \addtogroup LTQ_DMA_DRV_STRUCTURE
 */
/*@{*/

/*! \enum  dma_psuedeo_interrupts_t
* \brief DMA pseudo interrupts.
    These interrupts are generated by dma core driver to sync with client
    drivers to handle the data between the clinet and core driver.
*/
typedef enum {
	RCV_INT = 1,		/*!< Receive psuedo interrupt */
	TX_BUF_FULL_INT = 2,	/*!< Tx channel descriptors full interrupt */
	TRANSMIT_CPT_INT = 4, /*!< Tx channel descriptors available interrupt */
} dma_psuedeo_interrupts_t;

/*! \enum ifx_dma_channel_onoff_t
 \brief dma channel is on/ off.
*/
typedef enum {
	IFX_DMA_CH_OFF = 0,	/*!< DMA channel is OFF */
	IFX_DMA_CH_ON = 1,	/*!< DMA channel is ON */
} ifx_dma_channel_onoff_t;

/*! \enum ifx_dma_class_t
 \brief dma channel class value.
*/
typedef enum {
	IFX_DMA_CLASS_0 = 0,
	IFX_DMA_CLASS_1,
	IFX_DMA_CLASS_2,
	IFX_DMA_CLASS_3,
	IFX_DMA_CLASS_4,
	IFX_DMA_CLASS_5,
	IFX_DMA_CLASS_6,
	IFX_DMA_CLASS_7,
} ifx_dma_class_t;

/*! \enum ifx_dma_endian_t
 \brief DMA endiannes type.
*/
typedef enum {
	IFX_DMA_ENDIAN_TYPE0 = 0,	/*!< No byte Swapping */
	IFX_DMA_ENDIAN_TYPE1,	/*!< Byte Swap(B0B1B2B3 => B1B0B3B2) */
	IFX_DMA_ENDIAN_TYPE2,	/*!< Word Swap (B0B1B2B3 => B2B3B0B1) */
	IFX_DMA_ENDIAN_TYPE3,	/*!< DWord Swap (B0B1B2B3 => B3B2B1B0) */
} ifx_dma_endian_t;

enum {
    /** 2 DWORDS */
	IFX_DMA_BURSTL_2 = 1,
    /** 4 DWORDS */
	IFX_DMA_BURSTL_4 = 2,
    /** 8 DWORDS */
	IFX_DMA_BURSTL_8 = 3,
};

/*! \enum ifx_dma_burst_len_t
 \brief DMA Burst length.
*/
typedef enum {
	DMA_BURSTL_2DW = 2,	/*!< 2 DWORD DMA burst length */
	DMA_BURSTL_4DW = 4,	/*!< 4 DWORD DMA burst length */
	DMA_BURSTL_8DW = 8,	/*!< 8 DWORD DMA burst length
				(not supported by all peripherals) */
} ifx_dma_burst_len_t;

/*! \typedef _dma_arbitration_info
 \brief Parameter Structure to used to configure DMA arbitration
 based on packet or burst also Descriptor read back enabled/disabled
 (Supported only VR9)
 Used by reference dma_device_info
*/
typedef struct dma_arbitration_info {
	__u32 packet_arbitration; /*!< enabled/disabled packet arbitration */

	__u32 multiple_burst_arbitration; /*!< Enabled/Disabled Multi burst */
	 /*!< Counter of the Multi burst arbitration(Num of bursts that served
	  * before the arbitration of another peri port) */
	unsigned int multiple_burst_counter;
	__u32 desc_read_back;	/*!< enabled/disabled Descriptor read back */
} _dma_arbitration_info;

/*! \typedef _dma_channel_info
 \brief The parameter structure is used to configure the DMA channel info
 when the peripheral driver need to register with DMA core device driver.
*/
typedef struct dma_channel_info {
	int rel_chan_no;	/*!< Relative channel number */
	int dir;		/*!< Direction of channel */
	int irq;		/*!< DMA channel IRQ number */
	unsigned int desc_base;	/*!< Channel descriptor base address */
	int desc_len;		/*!< Num of descriptors per channel */
	int curr_desc;		/*!< Current Descriptor number */
	int prev_desc;		/*!< Previous Descriptor number */
	int byte_offset;	/*!< Byte offset */
	int desc_handle;	/*!< Descriptor handled flag
				( to handle Rx Descriptor by client driver) */
	int weight;		/*!< WFQ present weight value for DMA channel */
	int default_weight;	/*!< WFQ default weight value to handle in
				driver for DMA channel */
	int tx_channel_weight;	/*!< Config the Tx DMA channel weight value */
	ifx_dma_class_t class_value;	/*!< Config the DMA class value */
	int packet_size;	/*!< Size of the packet length */
	int channel_packet_drop_enable;	/*!< Config channel based packet drop
					(supported only VR9) */
	/*!< Channel based packet drop counter */
	int channel_packet_drop_counter;
	int peri_to_peri;	/*!< Config Peripheral to Peripheral
				(not supported Danube) */
	int global_buffer_len;	/*!< Config global buffer length, valid only
				when enabled peri_to_peri) */
	int loopback_enable;	/*!< Config Loop back between the DMA channels
				(Supported only VRx) */
	int loopback_channel_number;	/*!< Config the loopback Channel number
					(supported only VRx) */
	int req_irq_to_free;	/*!< Release the DMA channel IRQ, which was
				already requested */
	int dur;		/*!< Flag for Descriptor underrun interrupt */
	spinlock_t irq_lock;	/*!< spin lock */
	ifx_dma_channel_onoff_t control;	/*!< Channel on/off flag */
	void *opt[MAX_DMA_DESC_NUM];	/*!< Optional info */
	void *dma_dev;		/*!< Pointing to the devices */
	void (*open) (struct dma_channel_info *pCh);	/*!< DMA channel ON */
	void (*close) (struct dma_channel_info *pCh);	/*!< DMA channel OFF */
	void (*reset) (struct dma_channel_info *pCh); /*!< Reset DMA channel */
	/*!< Enable channel interrupt */
	void (*enable_irq) (struct dma_channel_info *pCh);
	/*!< Disable channel interrupt */
	void (*disable_irq) (struct dma_channel_info *pCh);
} _dma_channel_info;

/*! \typedef _dma_device_info
 \brief The parameter structure is used to configure the DMA Peripheral ports
 info when the peripheral driver need to register with DMA core device driver.
*/
typedef struct dma_device_info {
	char device_name[DMA_DEV_NAME_LEN];	/*!< Peripheral Device name */
	int port_reserved;	/*!< Reserve the device by client driver */
	int port_num;		/*!< Port number */
	ifx_dma_burst_len_t tx_burst_len; /*!< Configure the Tx burst length */
	ifx_dma_burst_len_t rx_burst_len; /*!< Conigure the Rx burst length */
	int port_tx_weight;	/*!< Configure the Port based weight value */
	int port_packet_drop_enable;	/*!< Packet drop Enabled/Disabled */
	int port_packet_drop_counter;	/*!< Packet drop counter */
	int mem_port_control;	/*!< Configure the mem port control,
				only used Memory Ports */
	ifx_dma_endian_t tx_endianness_mode; /*!< Configure TX Endiannes */
	ifx_dma_endian_t rx_endianness_mode;/*!< Configure RX Endiannes */
	int current_tx_chan;	/*!< Current Tx channel of the device */
	int current_rx_chan;	/*!< Current Rx channel of the device */
	int num_tx_chan;	/*!< Config the num of Tx channels for device */
	int num_rx_chan;	/*!< Config the num of Rx channels for device */
	int max_rx_chan_num;	/*!< Max number of Rx channels supported */
	int max_tx_chan_num;	/*!< Max number of Tx channels supported */
	spinlock_t irq_lock;	/*!< spin lock */
	_dma_arbitration_info arbitration_info;	/*!< arbitration config */
	_dma_channel_info * tx_chan[MAX_DMA_CHANNEL_NUM]; /*!< Max TX channel */
	_dma_channel_info * rx_chan[MAX_DMA_CHANNEL_NUM]; /*!< Max RX channel */
	u8 *(*buffer_alloc) (int len, int *offset, void **opt);
	int (*buffer_free) (u8 *dataptr, void *opt); /*!< Buffer free */
	/*!< DMA pseudo interrupt handler */
	int (*intr_handler) (struct dma_device_info *info, int status);
	/*!< activate the polling  (Used when NAPI enables) */
	void (*activate_poll) (struct dma_device_info *dma_dev);
	/*!< Deactivate the polling (used when NAPI enabled) */
	void (*inactivate_poll) (struct dma_device_info *dma_dev);
	void *priv;	/*!< Pointer to the device private structure */
} _dma_device_info;

/* @} */
/** Reserve the dma device port
*   This function should call before the dma_device_register */
extern _dma_device_info *dma_device_reserve(char *dev_name);

/** Unreseve the dma device port
*   This function will called after the dma_device_unregister */
extern int dma_device_release(_dma_device_info *dev);

/** Register with DMA device driver.
This function should call after dma_device_reserve function.
*   This function register with dma device driver to handle dma functionality.
*   Should provide the required configuration info during the register with
*   dma device.
*   if not provide config info, then take default values. */
extern int dma_device_register(_dma_device_info *info);

/** Unregister with DMA core driver
*   This function unregister with dma core driver. Once it unregister there is
*   no DMA handling with client driver.*/
extern int dma_device_unregister(_dma_device_info *info);

/** Read data packet from DMA Rx channel.
*   This function gets the data from the current rx descriptor of the DMA
*   channel and send to the client driver.
*   This functions is called when the client driver gets a pseudo DMA interrupt
*   (RCV_INT). Handle with care when call this function as well as
* dma_device_desc_setup function.*/
extern int dma_device_read(struct dma_device_info *info, u8 **dataptr,
			void **opt);

/** Write data Packet to DMA Tx channel.
*   This function gets the data packet from the client driver and send over on
*   DMA channel.*/
extern int dma_device_write(struct dma_device_info *info, u8 *dataptr,
			int len, void *opt);

/** Setup the DMA channel descriptor.
*   This function setup the descriptor of the DMA channel used by client driver.
*   The client driver will take care the buffer allocation and do proper
*   checking of buffer for DMA burst alignment.Handle with care when call this
*   function as well as dma_device_read function */
extern int dma_device_desc_setup(_dma_device_info *dma_dev, char *buf,
				size_t len);

/** Clear the interrupt status flag
*   This function used to exit from DMA tasklet(tasklet don't need to run again
*   and again ) This is also used to avoid multiple psuedo interrupt (RCV_INT)
*   per packet.*/
extern int dma_device_clear_int(_dma_device_info *dma_dev, int dir);

/**Clear the descriptor status word from the client driver once receive
    a pseudo interrupt(RCV_INT) from the DMA module to avoid duplicate
    interrupts from tasklet.
*/
extern int dma_device_clear_desc_status_word(_dma_device_info *dma_dev,
					int dir);

/** Poll the DMA device channel descriptors
*   This function polls the interrupts status in polling mode. */
extern int dma_device_poll(struct dma_device_info *info, int work_to_do,
			int *work_done);

/** setup the dma channel class value
*   This function setup the class of service value for DMA channel.*/
extern void dma_device_setup_class_val(_dma_channel_info *pCh, int cls);

/** poll DMA ownership bit to ensure that rx transactions are complete
*   to prevent descriptor errors */
extern void poll_dma_ownership_bit(_dma_device_info *dma_dev);
#endif /* LANTIQ_DMA_H */
